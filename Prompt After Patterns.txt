# üöÄ VIBECODING PROMPT: Student Services Website 
## Complete Full-Stack Implementation Guide

---

## üìã PROJECT OVERVIEW

I need you to build a **complete, production-ready Student Services Website** following an enterprise-grade architecture. This is a comprehensive system with **authentication, authorization, booking management, payment processing, notifications, and multiple design patterns**.

---

## üéØ CORE REQUIREMENTS

### **System Purpose:**
A web application where **students** can:
- Register and login securely
- Book accommodations, transportation, meals, and join clubs
- Make payments for services
- Receive notifications
- Manage their profile with undo/redo functionality
- Search and filter available services

**Admins** can:
- Manage all system resources
- View reports and analytics
- Configure system settings
- Manage user permissions

---

## üèóÔ∏è ARCHITECTURE SPECIFICATIONS

### **Technology Stack:**
- **Frontend:** React + TypeScript + Tailwind CSS
- **Backend Logic:** Implement in frontend with proper service architecture
- **State Management:** React Context API or Zustand
- **Routing:** React Router v6
- **Authentication:** JWT tokens (simulated)
- **Data Persistence:** LocalStorage or IndexedDB (simulate database)
- **Design:** Modern, responsive, accessible UI

### **Required Architecture Layers:**

#### **1. Entity Layer (Pure Data Objects):**
```typescript
// Student & Admin entities (NO authentication logic in these)
class Student {
  studentID: string;
  name: string;
  email: string;
  passwordHash: string;
  role: string;
  registrationDate: Date;
}

class Admin {
  adminID: string;
  name: string;
  email: string;
  passwordHash: string;
  role: string;
  permissions: string[];
}

// Business entities
class Accommodation { /* accommodationID, name, location, capacity, pricePerNight */ }
class Transport { /* transportID, type, schedule, seatsAvailable, pricePerSeat */ }
class Meal { /* mealID, name, type, price */ }
class Club { /* clubID, name, description, membershipFee */ }
class Payment { /* paymentID, studentID, amount, date, paymentMethod, status */ }
class Notification { /* notificationID, recipientID, message, dateSent, isRead */ }
class User { /* userID, email, passwordHash, role, createdDate */ }
class Role { /* roleID, roleName, permissions */ }
```

#### **2. Controller Layer:**
```typescript
interface IController {
  handleAccommodationRequest(studentID: string, accommodationID: string): void;
  handleTransportRequest(studentID: string, transportID: string): void;
  handleMealRequest(studentID: string, mealType: string): void;
  handleClubRequest(studentID: string, clubID: string): void;
  sendStudentNotification(studentID: string, message: string, type: string): void;
}

class Controller implements IController {
  // Delegates ALL requests to appropriate services
  // NO direct business logic here
}
```

#### **3. Service Layer (Business Logic):**

**Authentication Service:**
```typescript
interface IAuthenticationService {
  authenticate(email: string, password: string): AuthToken;
  register(userData: RegisterDTO): User;
  validateToken(token: string): boolean;
  logout(token: string): void;
  changePassword(userID: string, oldPassword: string, newPassword: string): boolean;
  resetPassword(email: string): void;
}
```

**Authorization Service:**
```typescript
interface IAuthorizationService {
  checkPermission(userID: string, resource: string, action: string): boolean;
  hasRole(userID: string, role: string): boolean;
}
```

**Business Services:**
```typescript
interface IPaymentService {
  processTransaction(amount: number, type: string): boolean;
}

interface IAccommodationService {
  bookHousing(studentID: string, accommodationID: string): void;
  cancelBooking(studentID: string, bookingID: string): void;
}

interface ITransportService {
  bookTransport(studentID: string, transportID: string): void;
  cancelBooking(studentID: string, bookingID: string): void;
}

interface IMealService {
  selectMeal(studentID: string, mealType: string): void;
  cancelMeal(studentID: string, mealID: string): void;
}

interface IClubService {
  chooseClub(studentID: string, clubID: string): void;
  cancelClubMembership(studentID: string, clubID: string): void;
}

interface INotificationService {
  sendNotification(recipientID: string, message: string, type: string): void;
  viewNotifications(userID: string): Notification[];
}
```

#### **4. Repository Layer:**
```typescript
interface IRepository {
  save(entity: any): void;
  findById(id: string): any;
  delete(id: string): void;
  update(entity: any): void;
  findAll(): any[];
  findByQuery(criteria: Record<string, any>): any[];
}
```

#### **5. Database Layer (Simulated):**
```typescript
// Singleton pattern
class DatabaseManager {
  private static instance: DatabaseManager;
  private constructor() { /* Initialize storage */ }
  static getInstance(): DatabaseManager;
  executeQuery(query: string): any;
  connect(): void;
}

// Proxy pattern (with access logging)
class DatabaseProxy {
  private realDatabase: DatabaseManager;
  checkAccess(): boolean;
  logAccess(query: string): void;
  executeQuery(query: string): any;
}
```

---

## üé® DESIGN PATTERNS TO IMPLEMENT

### **1. Creational Patterns:**

#### **Factory Method (Notification Creation):**
```typescript
interface INotification {
  send(): void;
}

interface INotificationFactory {
  createNotification(recipient: string, message: string): INotification;
}

class EmailFactory implements INotificationFactory { /* creates EmailNotification */ }
class SMSFactory implements INotificationFactory { /* creates SMSNotification */ }
```

#### **Abstract Factory (Meal Families):**
```typescript
interface IMealFactory {
  createMainDish(): MainDish;
  createDrink(): Drink;
  createDessert(): Dessert;
}

class RegularMealFactory implements IMealFactory { /* Burger, Soda, Ice Cream */ }
class HealthyMealFactory implements IMealFactory { /* Chicken, Juice, Fruit */ }
```

#### **Builder Pattern (Complex Meal Construction):**
```typescript
interface IMealBuilder {
  reset(): void;
  buildMain(): void;
  buildDrink(): void;
  buildDessert(): void;
  getResult(): MealProduct;
}

class MealDirector {
  private builder: IMealBuilder;
  setBuilder(builder: IMealBuilder): void;
  constructFullMeal(): MealProduct;
  constructLightMeal(): MealProduct;
}
```

#### **Singleton (Database Manager):**
```typescript
class DatabaseManager {
  private static instance: DatabaseManager;
  private constructor() {}
  static getInstance(): DatabaseManager {
    if (!DatabaseManager.instance) {
      DatabaseManager.instance = new DatabaseManager();
    }
    return DatabaseManager.instance;
  }
}
```

### **2. Structural Patterns:**

#### **Adapter Pattern (Payment Processing):**
```typescript
interface IPaymentProcessor {
  processPayment(amount: number): boolean;
}

class VisaPayment implements IPaymentProcessor { /* Standard interface */ }

class VCPayment {
  sendVirtualCoins(amt: number, cur: string, hash: string): boolean;
}

class VCAdapter extends VCPayment implements IPaymentProcessor {
  processPayment(amount: number): boolean {
    // Adapts VCPayment to IPaymentProcessor interface
    return this.sendVirtualCoins(amount, "USD", "hash123");
  }
}
```

#### **Proxy Pattern (Database Access Control):**
```typescript
class DatabaseProxy implements IDatabaseAccess {
  private realDatabase: DatabaseManager;
  
  checkAccess(): boolean { /* Security check */ }
  logAccess(query: string): void { /* Audit logging */ }
  
  executeQuery(query: string): any {
    if (!this.checkAccess()) throw new Error("Access denied");
    this.logAccess(query);
    return this.realDatabase.executeQuery(query);
  }
}
```

#### **Repository Pattern (Data Abstraction):**
```typescript
class Repository implements IRepository {
  private dbAccess: IDatabaseAccess;
  
  save(entity: any): void {
    this.dbAccess.executeQuery(`INSERT INTO...`);
  }
  
  findById(id: string): any {
    return this.dbAccess.executeQuery(`SELECT * WHERE id='${id}'`);
  }
}
```

### **3. Behavioral Patterns:**

#### **Strategy Pattern (Search Algorithms):**
```typescript
interface ISearchStrategy {
  search(criteria: string): any[];
}

class PriceStrategy implements ISearchStrategy {
  search(criteria: string): Accommodation[] {
    // Search by price range
  }
}

class LocationStrategy implements ISearchStrategy {
  search(criteria: string): Accommodation[] {
    // Search by location
  }
}

class SearchContext {
  private strategy: ISearchStrategy;
  setStrategy(strategy: ISearchStrategy): void;
  executeSearch(criteria: string): any[];
}
```

#### **State Pattern (Booking Status):**
```typescript
interface IBookingState {
  next(context: BookingContext): void;
  prev(context: BookingContext): void;
  printStatus(): void;
}

class PendingState implements IBookingState { /* Booking pending */ }
class ConfirmedState implements IBookingState { /* Booking confirmed */ }
class CancelledState implements IBookingState { /* Booking cancelled */ }

class BookingContext {
  private state: IBookingState;
  setState(state: IBookingState): void;
  requestNext(): void;
}
```

#### **Memento Pattern (Profile Undo/Redo):**
```typescript
class StudentProfile {
  private name: string;
  private email: string;
  
  save(): ProfileMemento {
    return new ProfileMemento(this.name, this.email);
  }
  
  restore(memento: ProfileMemento): void {
    this.name = memento.getName();
    this.email = memento.getEmail();
  }
}

class ProfileMemento {
  constructor(private name: string, private email: string) {}
  getName(): string { return this.name; }
  getEmail(): string { return this.email; }
}

class ProfileCaretaker {
  private history: ProfileMemento[] = [];
  
  saveState(profile: StudentProfile): void {
    this.history.push(profile.save());
  }
  
  undo(profile: StudentProfile): void {
    const memento = this.history.pop();
    if (memento) profile.restore(memento);
  }
}
```

---

## üé® UI/UX REQUIREMENTS

### **Design System:**
- **Color Scheme:** 
  - Primary: Modern blue (#3B82F6)
  - Secondary: Warm orange (#F59E0B)
  - Success: Green (#10B981)
  - Error: Red (#EF4444)
  - Neutral: Gray scale
  
- **Typography:**
  - Headings: Bold, clear hierarchy
  - Body: Readable, 16px base
  - Consistent spacing

- **Components:**
  - Modern cards with subtle shadows
  - Smooth transitions and animations
  - Loading states and skeletons
  - Toast notifications for feedback
  - Modal dialogs for confirmations
  - Responsive data tables
  - Interactive forms with validation

### **Required Pages:**

#### **1. Landing Page:**
- Hero section with CTA
- Feature highlights
- Login/Register buttons
- Modern, engaging design

#### **2. Authentication Pages:**
- **Login:** Email/password, "Remember me", "Forgot password"
- **Register:** Student vs Admin selection, form validation
- **Password Reset:** Email input, confirmation

#### **3. Student Dashboard:**
- Welcome message
- Quick stats (bookings, payments, notifications)
- Recent activity feed
- Quick action buttons

#### **4. Accommodation Page:**
- Grid/List view toggle
- Search bar with Strategy pattern (price/location filters)
- Cards showing: name, location, capacity, price
- "Book Now" button
- Booking state visualization (Pending/Confirmed)

#### **5. Transport Page:**
- Similar to Accommodation
- Show: type, schedule, seats available, price
- Real-time seat availability

#### **6. Meals Page:**
- Meal type selection (Regular/Healthy)
- Builder pattern UI: Select main dish, drink, dessert
- Visual meal composition
- Calorie calculator
- "Order" button

#### **7. Clubs Page:**
- Club cards with descriptions
- Membership fees
- "Join Club" button
- Member count

#### **8. Profile Page:**
- Edit profile form
- Undo/Redo buttons (Memento pattern)
- Change password
- View booking history
- Payment history

#### **9. Payment Page:**
- Payment method selection (Visa/Virtual Coins)
- Transaction summary
- Secure payment form
- Payment confirmation

#### **10. Notifications Page:**
- Notification list (read/unread)
- Mark as read functionality
- Notification types (Email/SMS indicators)
- Filter options

#### **11. Admin Dashboard:**
- System statistics
- User management table
- Resource management
- Reports and analytics

---

## üîê SECURITY REQUIREMENTS

### **Authentication:**
```typescript
// Password hashing (simulated)
class PasswordHasher {
  hash(password: string): string {
    // Use bcrypt-like simulation
    return btoa(password + "salt"); // In real app, use bcrypt
  }
  
  verify(password: string, hash: string): boolean {
    return this.hash(password) === hash;
  }
}

// JWT Token management (simulated)
class TokenManager {
  generateToken(user: User): string {
    const payload = {
      userId: user.userID,
      email: user.email,
      role: user.role,
      exp: Date.now() + 3600000 // 1 hour
    };
    return btoa(JSON.stringify(payload)); // In real app, use JWT library
  }
  
  validateToken(token: string): boolean {
    try {
      const payload = JSON.parse(atob(token));
      return payload.exp > Date.now();
    } catch {
      return false;
    }
  }
}
```

### **Authorization:**
```typescript
class AuthorizationService implements IAuthorizationService {
  private permissions = {
    STUDENT: ['accommodation:book', 'transport:book', 'meal:order', 'club:join'],
    ADMIN: ['user:manage', 'resource:manage', 'system:configure', '*:*']
  };
  
  checkPermission(userID: string, resource: string, action: string): boolean {
    const user = repository.findById(userID);
    const userPerms = this.permissions[user.role] || [];
    return userPerms.includes(`${resource}:${action}`) || userPerms.includes('*:*');
  }
  
  hasRole(userID: string, role: string): boolean {
    const user = repository.findById(userID);
    return user.role === role;
  }
}
```

### **Protected Routes:**
```typescript
// React Router protection
const ProtectedRoute = ({ children, requiredRole }) => {
  const { user, token } = useAuth();
  
  if (!token || !authService.validateToken(token)) {
    return <Navigate to="/login" />;
  }
  
  if (requiredRole && !authService.hasRole(user.id, requiredRole)) {
    return <Navigate to="/unauthorized" />;
  }
  
  return children;
};
```

---

## üìä DATA FLOW EXAMPLES

### **Example 1: Student Books Accommodation**
```
1. Student clicks "Book" on Accommodation card
2. UI ‚Üí Controller.handleAccommodationRequest(studentID, accommodationID)
3. Controller ‚Üí AccommodationService.bookHousing(studentID, accommodationID)
4. AccommodationService:
   a. Checks authorization (student has 'accommodation:book' permission)
   b. Validates availability via SearchContext
   c. Processes payment via PaymentService
   d. Creates booking with BookingContext (set to PendingState)
   e. Saves booking via Repository
5. Repository ‚Üí DatabaseProxy ‚Üí DatabaseManager ‚Üí LocalStorage
6. AccommodationService ‚Üí NotificationService.sendNotification()
7. UI updates: Show success message, update booking list
```

### **Example 2: Student Edits Profile with Undo**
```
1. Student edits profile (changes name/email)
2. Before saving, ProfileCaretaker.saveState(currentProfile)
3. Student saves changes ‚Üí Repository.update(student)
4. Student clicks "Undo"
5. ProfileCaretaker.undo(profile) ‚Üí Restores previous state
6. UI updates with old values
```

### **Example 3: Student Searches Accommodations**
```
1. Student selects "Search by Price" filter
2. SearchContext.setStrategy(new PriceStrategy())
3. Student enters price range
4. SearchContext.executeSearch("100-200")
5. PriceStrategy queries Repository with price criteria
6. Results displayed in grid
7. Student switches to "Search by Location"
8. SearchContext.setStrategy(new LocationStrategy())
9. Different search algorithm applied
```

---

## üéØ CRITICAL IMPLEMENTATION RULES

### **‚úÖ DO:**
1. **Keep entities as POJOs** - No business logic in Student/Admin classes
2. **Use dependency injection** - All services receive dependencies via constructor
3. **Depend on interfaces** - Services use IRepository, IPaymentService, etc.
4. **Implement all patterns correctly** - Follow the exact pattern structures
5. **Add loading states** - Show spinners during operations
6. **Handle errors gracefully** - Try-catch blocks, user-friendly error messages
7. **Validate all inputs** - Client-side validation before service calls
8. **Log important actions** - Use DatabaseProxy logging
9. **Make it responsive** - Mobile-first design with Tailwind
10. **Add animations** - Smooth transitions, fade-ins, hover effects

### **‚ùå DON'T:**
1. **Don't put authentication in entities** - Use AuthenticationService
2. **Don't let clients access repository directly** - Must go through Controller
3. **Don't skip pattern implementations** - All 13 patterns must be present
4. **Don't use localStorage directly in components** - Use Repository abstraction
5. **Don't hardcode permissions** - Use AuthorizationService
6. **Don't mix concerns** - Keep layers separate
7. **Don't skip error handling** - Every service call needs try-catch
8. **Don't forget loading states** - Users need feedback
9. **Don't ignore accessibility** - ARIA labels, keyboard navigation
10. **Don't use inline styles** - Use Tailwind classes

---

## üöÄ STEP-BY-STEP IMPLEMENTATION GUIDE

### **Phase 1: Foundation (Start Here)**
1. Set up React + TypeScript + Tailwind project
2. Create folder structure:
   ```
   src/
   ‚îú‚îÄ‚îÄ entities/          # POJOs
   ‚îú‚îÄ‚îÄ services/          # Business logic
   ‚îú‚îÄ‚îÄ repositories/      # Data access
   ‚îú‚îÄ‚îÄ database/          # Storage simulation
   ‚îú‚îÄ‚îÄ controllers/       # Request routing
   ‚îú‚îÄ‚îÄ patterns/          # Design pattern implementations
   ‚îÇ   ‚îú‚îÄ‚îÄ factory/
   ‚îÇ   ‚îú‚îÄ‚îÄ builder/
   ‚îÇ   ‚îú‚îÄ‚îÄ strategy/
   ‚îÇ   ‚îú‚îÄ‚îÄ state/
   ‚îÇ   ‚îî‚îÄ‚îÄ memento/
   ‚îú‚îÄ‚îÄ components/        # React components
   ‚îú‚îÄ‚îÄ pages/            # Route pages
   ‚îú‚îÄ‚îÄ hooks/            # Custom hooks
   ‚îî‚îÄ‚îÄ utils/            # Helpers
   ```

### **Phase 2: Core Architecture**
1. Implement DatabaseManager (Singleton)
2. Implement DatabaseProxy (with logging)
3. Implement Repository pattern
4. Create all entity classes
5. Implement AuthenticationService
6. Implement AuthorizationService

### **Phase 3: Business Services**
1. Implement PaymentService + Adapter pattern
2. Implement AccommodationService
3. Implement TransportService
4. Implement MealService + Builder pattern
5. Implement ClubService
6. Implement NotificationService + Factory pattern

### **Phase 4: Design Patterns**
1. Implement all Factory patterns
2. Implement Builder + Director
3. Implement Strategy pattern for search
4. Implement State pattern for bookings
5. Implement Memento pattern for profile

### **Phase 5: UI Components**
1. Create authentication pages
2. Create dashboard layouts
3. Create service booking pages
4. Create profile management
5. Create admin panel

### **Phase 6: Integration & Polish**
1. Connect all components to services
2. Add error handling everywhere
3. Add loading states
4. Implement notifications/toasts
5. Add animations and transitions
6. Test all user flows
7. Make fully responsive

---

## üé® EXAMPLE COMPONENT STRUCTURE

### **Example: Accommodation Booking Component**
```typescript
const AccommodationPage: React.FC = () => {
  // Services (injected via Context or props)
  const accommodationService = useService<IAccommodationService>('accommodation');
  const searchContext = useSearchContext();
  const { user } = useAuth();
  
  // State
  const [accommodations, setAccommodations] = useState<Accommodation[]>([]);
  const [loading, setLoading] = useState(false);
  const [searchStrategy, setSearchStrategy] = useState<'price' | 'location'>('price');
  
  // Handlers
  const handleSearch = async (criteria: string) => {
    setLoading(true);
    
    // Set strategy based on filter
    if (searchStrategy === 'price') {
      searchContext.setStrategy(new PriceStrategy());
    } else {
      searchContext.setStrategy(new LocationStrategy());
    }
    
    // Execute search
    const results = searchContext.executeSearch(criteria);
    setAccommodations(results);
    setLoading(false);
  };
  
  const handleBook = async (accommodationID: string) => {
    try {
      // Controller delegates to service
      await controller.handleAccommodationRequest(user.id, accommodationID);
      toast.success('Booking successful!');
      
      // Update UI
      // ... refresh bookings
    } catch (error) {
      toast.error('Booking failed: ' + error.message);
    }
  };
  
  return (
    <div className="container mx-auto p-6">
      <h1 className="text-3xl font-bold mb-6">Available Accommodations</h1>
      
      {/* Search Filters */}
      <SearchFilters 
        strategy={searchStrategy}
        onStrategyChange={setSearchStrategy}
        onSearch={handleSearch}
      />
      
      {/* Loading State */}
      {loading && <LoadingSpinner />}
      
      {/* Accommodation Grid */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        {accommodations.map(acc => (
          <AccommodationCard
            key={acc.accommodationID}
            accommodation={acc}
            onBook={() => handleBook(acc.accommodationID)}
          />
        ))}
      </div>
    </div>
  );
};
```

---

## üìù DELIVERABLES CHECKLIST

### **Code Quality:**
- [ ] All 13 design patterns implemented correctly
- [ ] All SOLID principles followed
- [ ] Clean separation of layers (Entity, Controller, Service, Repository, Database)
- [ ] TypeScript types for everything
- [ ] No any types (use proper interfaces)
- [ ] Error handling in all service methods
- [ ] Input validation on all forms

### **Features:**
- [ ] User registration (Student/Admin)
- [ ] Secure login with JWT tokens
- [ ] Password hashing
- [ ] Authorization checks on all protected routes
- [ ] Accommodation booking with search
- [ ] Transport booking
- [ ] Meal ordering with builder
- [ ] Club membership
- [ ] Payment processing (Visa/Virtual Coins)
- [ ] Notification system (Email/SMS)
- [ ] Profile editing with undo/redo
- [ ] Admin dashboard
- [ ] Booking state management (Pending/Confirmed/Cancelled)

### **UI/UX:**
- [ ] Responsive design (mobile, tablet, desktop)
- [ ] Loading states on all async operations
- [ ] Error messages displayed to users
- [ ] Success confirmations (toasts/modals)
- [ ] Smooth animations and transitions
- [ ] Accessible (ARIA labels, keyboard navigation)
- [ ] Modern, professional design
- [ ] Consistent styling throughout

### **Testing:**
- [ ] All authentication flows work
- [ ] All booking flows work
- [ ] Payment processing works
- [ ] Search strategies switch correctly
- [ ] State pattern transitions work
- [ ] Undo/redo works on profile
- [ ] Admin features work
- [ ] Error cases handled gracefully

---

## üéØ SUCCESS CRITERIA

Your implementation will be considered **excellent** if it:

1. ‚úÖ Implements ALL 13 design patterns correctly
2. ‚úÖ Follows the exact architecture (Entity ‚Üí Controller ‚Üí Service ‚Üí Repository ‚Üí Database)
3. ‚úÖ Has NO authentication logic in Student/Admin entities
4. ‚úÖ All services depend on interfaces (not concrete classes)
5. ‚úÖ Has proper security (hashing, tokens, authorization)
6. ‚úÖ UI is modern, responsive, and polished
7. ‚úÖ All user flows work end-to-end
8. ‚úÖ Code is clean, typed, and well-organized
9. ‚úÖ Has proper error handling and loading states
10. ‚úÖ Demonstrates deep understanding of software architecture

---

## üí° FINAL TIPS

1. **Start with the architecture, not the UI** - Build DatabaseManager ‚Üí Repository ‚Üí Services first
2. **Test each pattern as you build it** - Don't move on until it works
3. **Use TypeScript strictly** - It will catch architectural mistakes
4. **Keep components thin** - Business logic goes in services, not components
5. **Make it visual** - Add console.logs to show patterns executing
6. **Focus on one feature at a time** - Complete authentication before bookings
7. **Don't skip the patterns** - They're the heart of this project
8. **Make the UI beautiful** - Use Tailwind effectively
9. **Add micro-interactions** - Hover effects, transitions, animations
10. **Test the happy path AND error cases** - Both should work perfectly

---

## üöÄ NOW BUILD IT!

**Start with:** "Let's build the Student Services Website. First, create the complete project structure with all folders, then implement the DatabaseManager singleton pattern with the DatabaseProxy. Show me the code."

**Remember:** This is an **enterprise-grade application**. Every line of code should reflect professional software engineering practices. Make it **production-ready**, **secure**, **maintainable**, and **beautiful**.

**Good luck! üéâ**